import word2vec, newmicro
from penseur import penseur
w2v = word2vec.load('data/tagged.bin')
pens = penseur.Penseur()
formats = newmicro.makeFormats(w2v)
newmicro.doit(formats,w2v,pens)



#recursive; returns list of POS in order
def poss(node,l = None):
	if l is None:
		l = [None,None,None,None,None,None]
	l[node['index']] = node['pos']
	for c in node['children']:
		l = poss(c,l)
	return l

from collections import defaultdict
d = defaultdict(list)
for f in formats:
	f = f[3]
	print f['raw']
	s = " ".join(poss(f['root']))
	if s in d:
		print "DUPE:",s,f['raw']
	d[s].append(f)
	print s






def icheck(node,seen=None):
	if seen is None:
		seen = set()
	seen.add(node['index'])
	for c in node['children']:
		seen = icheck(c,seen)
	return seen

for i,f in enumerate(formats):
	f = f[3]
	s = icheck(f['root'])
	if not s == set([0,1,2,3,4,5]):
		print "BAD",i,":", f['raw'], s, "(",f['plug'],")"
#newmicro now filters these out... maybe don't filter so I can poke around in REPL and see what's wrong?
	


import re
def findR(formats, regex):
	for f in formats:
		f = f[3]
		if "'" not in f['raw'] and re.search(regex, f['plug']):
			print f['raw'],f['plug']


ws = list(set([f[3]['plug'] for f in formats]))
cs = set()
for w in ws:
	for c in w:
		cs.add(c)

for c in cs:
	sub = [w for w in ws if c in w]
	if len(sub) < 5:
		print c
		for s in sub:
			print '\t%s'%s
	else:
		print c, len(sub), sub[0]





#generate list of concat'ed POS (in order!) for each story
from collections import defaultdict
def posrec(node,curr):
	p = node['pos']
	if p.startswith("VB"):
		p="VB"
	if p.startswith("NN"):
		p="NN"
	#NOTE: TODO find more equiv POS(?)
	curr[node['index']]=
	for c in node['children']:
		posrec(c,curr)
	return curr

poss = []
for tup in formats:
	f = tup[3]
	poss.append(''.join(posrec(f['root'],[None,None,None,None,None,None])))

interpos = defaultdict(list) #dictionary of format index to list of other indices that have same POS
for i,c in enum(poss):
	for j,p in enum(poss):
		if c == p:
			interpos[i].append(j)
